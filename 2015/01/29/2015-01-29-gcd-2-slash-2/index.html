<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"loveltyoic.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文译自Grand Central Dispatch Tutorial for Swift: Part 2&#x2F;2  欢迎来到本GCD教程的第二同时也是最终部分！ 在第一部分中，你学到了并发，线程以及GCD的工作原理。通过使用dispatch_barrrier和dispatch_sync，你做到了让PhotoManager单例在读写照片时是线程安全的。除此之外，你用到dispatch_after来提">
<meta property="og:type" content="article">
<meta property="og:title" content="在Swift中应用Grand Central Dispatch(下）">
<meta property="og:url" content="http://loveltyoic.github.io/2015/01/29/2015-01-29-gcd-2-slash-2/index.html">
<meta property="og:site_name" content="Think Different">
<meta property="og:description" content="本文译自Grand Central Dispatch Tutorial for Swift: Part 2&#x2F;2  欢迎来到本GCD教程的第二同时也是最终部分！ 在第一部分中，你学到了并发，线程以及GCD的工作原理。通过使用dispatch_barrrier和dispatch_sync，你做到了让PhotoManager单例在读写照片时是线程安全的。除此之外，你用到dispatch_after来提">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM.png">
<meta property="og:image" content="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Thread_All_The_Code_Meme.jpg">
<meta property="og:image" content="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/What_Meme.jpg">
<meta property="og:image" content="http://cdn5.raywenderlich.com/wp-content/uploads/2014/08/GooglyPuff_Swift_signal_break.png">
<meta property="og:image" content="http://cdn3.raywenderlich.com/wp-content/uploads/2014/08/GooglyPuff_Swift_woot-271x500.png">
<meta property="article:published_time" content="2015-01-29T13:30:00.000Z">
<meta property="article:modified_time" content="2020-07-02T07:12:30.193Z">
<meta property="article:author" content="李梓赫">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM.png">

<link rel="canonical" href="http://loveltyoic.github.io/2015/01/29/2015-01-29-gcd-2-slash-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>在Swift中应用Grand Central Dispatch(下） | Think Different</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Think Different</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://loveltyoic.github.io/2015/01/29/2015-01-29-gcd-2-slash-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李梓赫">
      <meta itemprop="description" content="这是一个分享技术与生活感悟的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Think Different">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          在Swift中应用Grand Central Dispatch(下）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-01-29 21:30:00" itemprop="dateCreated datePublished" datetime="2015-01-29T21:30:00+08:00">2015-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-02 15:12:30" itemprop="dateModified" datetime="2020-07-02T15:12:30+08:00">2020-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Swift-GCD/" itemprop="url" rel="index"><span itemprop="name">Swift GCD</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>本文译自<a href="http://www.raywenderlich.com/79150/grand-central-dispatch-tutorial-swift-part-2" target="_blank" rel="noopener">Grand Central Dispatch Tutorial for Swift: Part 2/2</a></p>
</blockquote>
<p>欢迎来到本GCD教程的第二同时也是最终部分！</p>
<p>在第一部分中，你学到了并发，线程以及GCD的工作原理。通过使用<code>dispatch_barrrier</code>和<code>dispatch_sync</code>，你做到了让<code>PhotoManager</code>单例在读写照片时是线程安全的。除此之外，你用到<code>dispatch_after</code>来提示用户，优化了用户体验。还有，使用<code>dispatch_async</code>异步执行CPU密集型任务，从而为视图控制器初始化过程减负。</p>
<a id="more"></a>

<p>如果你跟着教程做，现在可以从第一部分的示例工程继续。如果你没有完成第一部分或不想再用你的工程，可以<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2015/01/GooglyPuff_Swift_End_1_Xcode61_start.zip" target="_blank" rel="noopener">下载第一部分的完成文件</a>。</p>
<p>是时候进一步探索GCD了！</p>
<h2 id="纠正过早出现的弹窗"><a href="#纠正过早出现的弹窗" class="headerlink" title="纠正过早出现的弹窗"></a>纠正过早出现的弹窗</h2><p>你可能注意到，当你通过 <strong>Le Internet</strong> 选项添加照片时，会有提示框在图片下载完成之前就弹出，如下图：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM.png" alt=""></p>
<p>错误在于 <code>PhotoManager</code> 里的 <code>downloadPhotosWithCompletion</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123;</span><br><span class="line">  var storedError: NSError!</span><br><span class="line">  for address in [OverlyAttachedGirlfriendURLString,</span><br><span class="line">                  SuccessKidURLString,</span><br><span class="line">                  LotsOfFacesURLString] &#123;</span><br><span class="line">    let url &#x3D; NSURL(string: address)</span><br><span class="line">    let photo &#x3D; DownloadPhoto(url: url!) &#123;</span><br><span class="line">      image, error in</span><br><span class="line">      if error !&#x3D; nil &#123;</span><br><span class="line">        storedError &#x3D; error</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PhotoManager.sharedManager.addPhoto(photo)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  if let completion &#x3D; completion &#123;</span><br><span class="line">    completion(error: storedError)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在方法的最后调用<code>completion</code>闭包——你会想当然的认为所有图片都下载完了。但不幸的是，在此时无法保证。</p>
<p><code>DownloadPhoto</code>类的实例方法从一个URL下载图片并且不等下载完成就立即退出。换言之，<code>downloadPhotosWithCompletion</code>在最后调用<code>completion</code>闭包，就好像其中的所有方法都在顺序执行，并且在每个方法完成后才执行下一个。</p>
<p>然而，<code>DownloadPhoto(url:)</code>是异步并且立即返回的——所以目前的方式不能正常工作。</p>
<p><code>downloadPhotosWithCompletion</code>应该在所有图片下载任务都完成后再调用自己的<code>completion</code>闭包。问题是：你怎么监视并发的异步事件呢？你不知道它们何时完成，以何种顺序。</p>
<p>也许你可以用多个<code>Bool</code>值来追踪下载情况，但那不容易扩展。而且坦白讲，那是很丑陋的代码。</p>
<p>幸运的是，<strong>dispatch groups</strong>就是专为监视多个异步任务的完成情况而设计的。</p>
<h3 id="调度组（Dispatch-Groups）"><a href="#调度组（Dispatch-Groups）" class="headerlink" title="调度组（Dispatch Groups）"></a>调度组（Dispatch Groups）</h3><p>调度组在一组任务都完成后会发出通知。这些任务可以是异步或同步的，甚至可以分布在不同的队列。调度组还可以通过同步或异步的方式来通知。因为任务在不同的队列中，<code>disptch_group_t</code>实例用来追踪队列中的不同任务。</p>
<p>在组内所有事件都完成时，GCD API提供了两种方式发送通知。</p>
<p>第一种是<code>dispatch_group_wait</code>，它会阻塞当前进程，直到所有任务都完成或是等待超时。这正是我们的例子中需要的方式。</p>
<p>打开 <strong>PhotoManager.swift</strong> ，替换<code>downloadPhotosWithCompletion</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123;</span><br><span class="line">  dispatch_async(GlobalUserInitiatedQueue) &#123; &#x2F;&#x2F; 1</span><br><span class="line">    var storedError: NSError!</span><br><span class="line">    var downloadGroup &#x3D; dispatch_group_create() &#x2F;&#x2F; 2</span><br><span class="line"> </span><br><span class="line">    for address in [OverlyAttachedGirlfriendURLString,</span><br><span class="line">                    SuccessKidURLString,</span><br><span class="line">                    LotsOfFacesURLString]</span><br><span class="line">    &#123;</span><br><span class="line">      let url &#x3D; NSURL(string: address)</span><br><span class="line">      dispatch_group_enter(downloadGroup) &#x2F;&#x2F; 3</span><br><span class="line">      let photo &#x3D; DownloadPhoto(url: url!) &#123;</span><br><span class="line">        image, error in</span><br><span class="line">        if let error &#x3D; error &#123;</span><br><span class="line">          storedError &#x3D; error</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(downloadGroup) &#x2F;&#x2F; 4</span><br><span class="line">      &#125;</span><br><span class="line">      PhotoManager.sharedManager.addPhoto(photo)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER) &#x2F;&#x2F; 5</span><br><span class="line">    dispatch_async(GlobalMainQueue) &#123; &#x2F;&#x2F; 6</span><br><span class="line">      if let completion &#x3D; completion &#123; &#x2F;&#x2F; 7</span><br><span class="line">        completion(error: storedError)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逐一来看注释：</p>
<ol>
<li>因为使用<code>dispatch_group_wait</code>阻塞了当前进程，要用<code>dispatch_async</code>将整个方法放到后台队列，才能保证主线程不被阻塞。</li>
<li>创建一个调度组，作用好比未完成任务的计数器。</li>
<li><code>dispatch_group_enter</code>通知调度组一个任务已经开始。你必须保证<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>是成对调用的，否则程序会崩溃。</li>
<li>通知任务已经完成。再一次，这里保持进和出相匹配。</li>
<li><code>dispatch_group_wait</code>等待所有任务都完成直到超时。如果在任务完成前就超时了，函数会返回一个非零值。可以通过返回值来判断是否等待超时；不过，这里你用<code>DISPATCH_TIME_FOREVER</code>来表示一直等待。这意味着，它会永远等待！没关系，因为图片总是会下载完的。</li>
<li>此时，你可以保证所有图片任务都完成或是超时了。接下来在主队列中加入完成闭包。闭包晚些时候会在主线程中执行。</li>
<li>执行闭包。</li>
</ol>
<p>运行app，下载几张图片，留意你的app是如何表现的。</p>
<blockquote>
<p><strong>Note</strong>：如果网速太快以至于分辨不出何时执行的闭包，你可以修改设备的设置。在 <strong>Setting</strong> 中的<strong>Developer Section</strong> 。打开 <strong>Network Link Conditioner</strong>，选择“Very Bad Network”。</p>
</blockquote>
<blockquote>
<p>如果在模拟器上，用<a href="http://nshipster.com/network-link-conditioner/" target="_blank" rel="noopener">工具</a>变更网速。这是你武器库中一个很好的工具，它让你清楚在不佳的网络下你的app会发生什么。</p>
</blockquote>
<p>这个方案目前不错，但最好能避免阻塞进程。你下一步的工作是重写这个方法来异步通知下载完成。</p>
<p>在学习下一个调度组的用法前，先看看怎样在不同的队列类型下使用调度组。</p>
<ul>
<li><strong>自定义串行队列</strong>：好选择。当一组任务完成时用它发送通知。</li>
<li><strong>主队列（串行）</strong>：在当前情景下是不错的选择。但你要谨慎地在主队列中使用，因为同步等待所有任务会阻塞主线程。然而，当一个需要较长时间的任务（比如网络请求）完成时，异步更新UI是很好的选择。</li>
<li><strong>并发队列</strong>：好选择。用于调度组和通知。</li>
</ul>
<h3 id="调度组，再来一次"><a href="#调度组，再来一次" class="headerlink" title="调度组，再来一次"></a>调度组，再来一次</h3><p>做的不错，但是异步调度到另一个队列然后用 <strong>dispatch_group_wait</strong> 阻塞还是有一些笨拙。还有另一种方式…</p>
<p>在 <strong>PhotoManager.swift</strong> 中找到<code>downloadPhotosWithCompletion</code>并替换之：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123;</span><br><span class="line">  &#x2F;&#x2F; 1</span><br><span class="line">  var storedError: NSError!</span><br><span class="line">  var downloadGroup &#x3D; dispatch_group_create()</span><br><span class="line"> </span><br><span class="line">  for address in [OverlyAttachedGirlfriendURLString,</span><br><span class="line">                  SuccessKidURLString,</span><br><span class="line">                  LotsOfFacesURLString]</span><br><span class="line">  &#123;</span><br><span class="line">    let url &#x3D; NSURL(string: address)</span><br><span class="line">    dispatch_group_enter(downloadGroup)</span><br><span class="line">    let photo &#x3D; DownloadPhoto(url: url!) &#123;</span><br><span class="line">      image, error in</span><br><span class="line">      if let error &#x3D; error &#123;</span><br><span class="line">        storedError &#x3D; error</span><br><span class="line">      &#125;</span><br><span class="line">      dispatch_group_leave(downloadGroup)</span><br><span class="line">    &#125;</span><br><span class="line">    PhotoManager.sharedManager.addPhoto(photo)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  dispatch_group_notify(downloadGroup, GlobalMainQueue) &#123; &#x2F;&#x2F; 2</span><br><span class="line">    if let completion &#x3D; completion &#123;</span><br><span class="line">      completion(error: storedError)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步方法是如何工作的：</p>
<ol>
<li>新的实现不需要把方法放进<code>dispatch_async</code>中，因为你并没有阻塞主线程。</li>
<li><code>dispatch_group_notify</code>异步执行闭包。当调度组内没有剩余任务的时候闭包才执行。同样要指明在哪个队列中执行闭包。当下，你需要在主队列中执行闭包。</li>
</ol>
<p>这是更优雅的方法，并且不会阻塞任何进程。</p>
<h2 id="并发过多带来的危险"><a href="#并发过多带来的危险" class="headerlink" title="并发过多带来的危险"></a>并发过多带来的危险</h2><p>通过支配这些新工具，你应该将每件事都线程化，对吗？</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Thread_All_The_Code_Meme.jpg" alt=""></p>
<p>看看<code>PhotoManager</code>中的<code>downloadPhotosWithCompletion</code>。你会发现通过<code>for</code>循环下载了三张图片。现在来看看能否通过并发执行<code>for</code>循环来提速。</p>
<p>是时候请出<code>dispatch_apply</code>了。</p>
<p><code>dispatch_apply</code>像<code>for</code>循环一样，只不过它会并发地执行循环过程。这个函数是同步的，所以像普通的<code>for</code>循环一样，<code>dispatch_apply</code>在所有工作都完成后才返回。</p>
<p>要注意循环的最佳次数，如果有太多循环但每个循环内只有很小的工作量，那么额外的开销会抹杀掉并发带来的好处。 <strong>步进</strong> (striding)可以帮助到你。它让你在每次循环中做多件工作。</p>
<p>什么时候用<code>dispatch_apply</code>合适？</p>
<ul>
<li><strong>自定义串行队列</strong>：在串行队列中使用<code>dispatch_apply</code>完全无意义；它的效果和<code>for</code>循环一样。</li>
<li><strong>主队列（串行）</strong>：理由同上，用<code>for</code>循环就可以了。</li>
<li><strong>并发队列</strong>：明智之选，尤其是你需要追踪任务进度时。</li>
</ul>
<p>替换<code>downloadPhotosWithCompletion</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123;</span><br><span class="line">  var storedError: NSError!</span><br><span class="line">  var downloadGroup &#x3D; dispatch_group_create()</span><br><span class="line">  let addresses &#x3D; [OverlyAttachedGirlfriendURLString,</span><br><span class="line">                   SuccessKidURLString,</span><br><span class="line">                   LotsOfFacesURLString]</span><br><span class="line"> </span><br><span class="line">  dispatch_apply(UInt(addresses.count), GlobalUserInitiatedQueue) &#123;</span><br><span class="line">    i in</span><br><span class="line">    let index &#x3D; Int(i)</span><br><span class="line">    let address &#x3D; addresses[index]</span><br><span class="line">    let url &#x3D; NSURL(string: address)</span><br><span class="line">    dispatch_group_enter(downloadGroup)</span><br><span class="line">    let photo &#x3D; DownloadPhoto(url: url!) &#123;</span><br><span class="line">      image, error in</span><br><span class="line">      if let error &#x3D; error &#123;</span><br><span class="line">        storedError &#x3D; error</span><br><span class="line">      &#125;</span><br><span class="line">      dispatch_group_leave(downloadGroup)</span><br><span class="line">    &#125;</span><br><span class="line">    PhotoManager.sharedManager.addPhoto(photo)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  dispatch_group_notify(downloadGroup, GlobalMainQueue) &#123;</span><br><span class="line">    if let completion &#x3D; completion &#123;</span><br><span class="line">      completion(error: storedError)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你的循环可以并发执行了；调用 <strong>dispatch_apply</strong> 时，第一个参数是循环的次数，第二个参数是执行任务的队列，第三个参数是闭包。</p>
<p>尽管你的代码在添加图片时是线程安全的，但是图片的顺序取决于线程完成的顺序。</p>
<p>运行app，用 <strong>Le Internet</strong> 添加一些图片，发现不同了吗？</p>
<p>在真机上运行新的代码会发现 <em>些许</em> 的速度提升。但是这值得吗？</p>
<p>实际上，在这里并不值得这么做。原因如下：</p>
<ul>
<li>你很可能因为并行而花费了比<code>for</code>循环更多的开销。你应该结合合适的步长对 <em>非常大</em> 的集合使用<code>dispatch_apply</code>。</li>
<li>开发app的时间有限——不要花时间过早优化。如果你想优化，那么就优化那些值得优化的东西。用Instruments测试app以找到最耗时间的方法。<a href="http://www.raywenderlich.com/?p=23037" target="_blank" rel="noopener">如何使用Instruments</a>。</li>
<li>一般说来，代码优化会让你的代码变得更复杂。你要确定带来的好处值得你增加复杂性。</li>
</ul>
<p>记住，不要痴迷于优化。否则只会让你自己为难，也让看你代码的人抓狂。</p>
<h2 id="取消调度块"><a href="#取消调度块" class="headerlink" title="取消调度块"></a>取消调度块</h2><p>iOS 8 和 OS X Yosemite引入了 <strong>调度对象块</strong> （dispatch block object）。它们实现起来就像对闭包再包装一层。调度对象块可以做到很多事情，比如为队列中的对象设置QoS等级来决定优先级，但最显著的能力是可以取消块的执行。要明白对象块只有在轮到它执行之前才可以取消（一旦开始执行就不能取消了）。</p>
<p>为了说明这个问题，首先用 <strong>Le Internet</strong> 下载一些图片，然后取消它们。替换 <strong>PhotoManager.swift</strong> 中的<code>downloadPhotosWithCompletion</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123;</span><br><span class="line">  var storedError: NSError!</span><br><span class="line">  let downloadGroup &#x3D; dispatch_group_create()</span><br><span class="line">  var addresses &#x3D; [OverlyAttachedGirlfriendURLString,</span><br><span class="line">                   SuccessKidURLString,</span><br><span class="line">                   LotsOfFacesURLString]</span><br><span class="line">  addresses +&#x3D; addresses + addresses &#x2F;&#x2F; 1</span><br><span class="line">  var blocks: [dispatch_block_t] &#x3D; [] &#x2F;&#x2F; 2</span><br><span class="line"> </span><br><span class="line">  for i in 0 ..&lt; addresses.count &#123;</span><br><span class="line">    dispatch_group_enter(downloadGroup)</span><br><span class="line">    let block &#x3D; dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS) &#123; &#x2F;&#x2F; 3</span><br><span class="line">      let index &#x3D; Int(i)</span><br><span class="line">      let address &#x3D; addresses[index]</span><br><span class="line">      let url &#x3D; NSURL(string: address)</span><br><span class="line">      let photo &#x3D; DownloadPhoto(url: url!) &#123;</span><br><span class="line">        image, error in</span><br><span class="line">        if let error &#x3D; error &#123;</span><br><span class="line">          storedError &#x3D; error</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(downloadGroup)</span><br><span class="line">      &#125;</span><br><span class="line">      PhotoManager.sharedManager.addPhoto(photo)</span><br><span class="line">    &#125;</span><br><span class="line">    blocks.append(block)</span><br><span class="line">    dispatch_async(GlobalMainQueue, block) &#x2F;&#x2F; 4</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  for block in blocks[3 ..&lt; blocks.count] &#123; &#x2F;&#x2F; 5</span><br><span class="line">    let cancel &#x3D; arc4random_uniform(2) &#x2F;&#x2F; 6</span><br><span class="line">    if cancel &#x3D;&#x3D; 1 &#123;</span><br><span class="line">      dispatch_block_cancel(block) &#x2F;&#x2F; 7</span><br><span class="line">      dispatch_group_leave(downloadGroup) &#x2F;&#x2F; 8</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  dispatch_group_notify(downloadGroup, GlobalMainQueue) &#123;</span><br><span class="line">    if let completion &#x3D; completion &#123;</span><br><span class="line">      completion(error: storedError)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>扩展<code>addresses</code>数组，将每个地址复制3份。</li>
<li>这个数组用来保存接下来创建的对象块。</li>
<li><code>dispatch_block_create</code>创建一个对象块。第一个参数是一个表明了块特征的标志。此处的标志让块从它进入的队列那里继承QoS等级。第二个参数是闭包形式的块定义。</li>
<li>块被异步的调度到全局主队列。这里用全局主队列是因为它是一个串行队列，可以方便我们取消对象块。当前代码已经在主线程中执行着，所以你可以保证下载任务将在此之后才执行（也就是这个<code>downloadPhotosWithCompletion</code>返回后才轮到下载任务执行）。</li>
<li>取数组中第三个到结尾的部分。</li>
<li><code>arc4random_uniform</code>会随机返回一个0到上界之间（不含上界）的整数。以2为上界会得到0或1，像投硬币一样。</li>
<li>如果随机数是1，则取消块。前提是，块还在队列中并且没开始。块在执行的过程中是不可以取消的。</li>
<li>因为所有块都加入调度组了，不要忘记移除被取消的那些块。</li>
</ol>
<p>运行，从 <strong>Le Internet</strong> 添加图片。你会看到app下载3张图片，以及随机数量的额外图片。那些没下载的图片是因为在加入队列 <em>后</em> 被取消了。这是一个刻意设计的例子，但是很好的演示了怎样使用调度对象块以及如何取消它。</p>
<p>调度对象块能做更多事情，别忘了查看文档。</p>
<h2 id="五花八门的GCD趣用"><a href="#五花八门的GCD趣用" class="headerlink" title="五花八门的GCD趣用"></a>五花八门的GCD趣用</h2><p>等等！还有更多！下面展示一些常规用途之外的功能。尽管你不会经常使用这些工具，但他们可能在特定情况下非常有用。</p>
<h3 id="测试异步代码"><a href="#测试异步代码" class="headerlink" title="测试异步代码"></a>测试异步代码</h3><p>这听起来很疯狂，但是你知道Xcode拥有测试功能吗？:]我知道，有时我喜欢假装它不存在，但是编写和运行测试对构建复杂的代码很重要。</p>
<p>Xcode中的测试运行在<code>XCTestCase</code>的子类之下，它会运行所有以<code>test</code>开头的方法。测试跑在主线程下，所以你可以认为测试是顺序执行的。</p>
<p>一旦给定的测试方法返回了，<strong>XCTest</strong> 会认为这个测试完成了而去做下一个测试。这就是说，在下一个测试执行过程中，前一个测试中的异步代码也在继续执行。</p>
<p>网路请求通常是异步的，因为你不想阻塞主线程。一旦测试方法返回，测试也就结束了，因此很难对网络请求做测试。</p>
<p>我们简单看一下两种普遍的测试异步代码的方法：<strong>信号量</strong>（semaphores）和 <strong>期望</strong>（expectations）。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一个古老学院派的线程概念，它是由谦逊的Edsger W. Dijkstra提出的。信号量是很复杂的话题，因为它建立在错综复杂的操作系统函数之上。</p>
<p>如果你想了解更多信号量的知识，查阅<a href="http://greenteapress.com/semaphores/" target="_blank" rel="noopener">细说信号量原理</a>。如果你是学院派，有一个用到了信号量的经典软件开发问题叫做<a href="http://en.wikipedia.org/wiki/Dining_philosophers_problem" target="_blank" rel="noopener">哲学家进餐问题</a>。</p>
<p>信号量让你控制多个消费者对有限资源的获取。例如，如果你创建一个信号量来控制拥有2个资源的资源池，那么同一时刻最多有两个线程可以进入临界区。其它也想使用资源的线程必须在FIFO队列中等待。</p>
<p>打开 <strong>GooglyPuffTests.swift</strong> 并替换掉 <code>downloadImageURLWithString</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func downloadImageURLWithString(urlString: String) &#123;</span><br><span class="line">  let url &#x3D; NSURL(string: urlString)</span><br><span class="line">  let semaphore &#x3D; dispatch_semaphore_create(0) &#x2F;&#x2F; 1</span><br><span class="line">  let photo &#x3D; DownloadPhoto(url: url!) &#123;</span><br><span class="line">    image, error in</span><br><span class="line">    if let error &#x3D; error &#123;</span><br><span class="line">      XCTFail(&quot;\(urlString) failed. \(error.localizedDescription)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(semaphore) &#x2F;&#x2F; 2</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  let timeout &#x3D; dispatch_time(DISPATCH_TIME_NOW, DefaultTimeoutLengthInNanoSeconds)</span><br><span class="line">  if dispatch_semaphore_wait(semaphore, timeout) !&#x3D; 0 &#123; &#x2F;&#x2F; 3</span><br><span class="line">    XCTFail(&quot;\(urlString) timed out&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中信号量的工作原理：</p>
<ol>
<li>创建信号量。参数表明信号量起始值。这个值代表了起始阶段可以获取信号量的线程数目（增加信号量就是发信号，用0做初始值代表当前没有线程可以获取信号量）。</li>
<li>在完成闭包中，你告诉信号量不再需要资源。这会使信号量增加，同时给其他等待资源的任务发信号，通知当前信号量可用。</li>
<li>等待信号量并设置超时时间。这个调用会阻塞当前进程直到收到信号。非0返回表示等待已超时。在这种情况下，测试失败，因为网络请求不应该超过10秒——相当合理的假设！<br>（译者注：说下我的理解：首先创建了信号量，但此时因为信号量是0，没有线程可以获取它，注释3中对信号量的等待会阻塞。只有在图片下载好了以后，才会发送一个信号量，那么注释3对信号量的获取就成功了，并退出等待。但如果图片下载失败呢？就不会调用注释2这句触发信号的语句，那么注释3就会等待超时，从而测试失败。）</li>
</ol>
<p><strong>Product/Test</strong> 或 <strong>⌘+U</strong> 运行测试。测试应该成功。</p>
<p>断掉网络连接并再次测试；如果在真机测试，请开启飞行模式。如果在模拟器上，直接断网就好了。测试在10秒后会返回失败的结果。很好，起作用了！</p>
<p>这是相当微不足道的测试，但是如果你和服务端团队一起工作，这些基础测试可以避免一些涉及网络问题的无端指责。</p>
<h3 id="期望（expectations）"><a href="#期望（expectations）" class="headerlink" title="期望（expectations）"></a>期望（expectations）</h3><p><code>XCTest</code>框架提供了另一种使用 <strong>期望</strong> 来测试异步代码的方法。这种特性让你首先设置你的期望——你希望发生的事——然后再开始异步任务。接下来测试会一直等待，直到异步任务将期望标记为 <em>已完成</em> 。</p>
<p>替换 <strong>GooglyPuffTests.swift</strong> 中的<code>downloadImageURLWithString</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func downloadImageURLWithString(urlString: String) &#123;</span><br><span class="line">  let url &#x3D; NSURL(string: urlString)</span><br><span class="line">  let downloadExpectation &#x3D; expectationWithDescription(&quot;Image downloaded from \(urlString)&quot;) &#x2F;&#x2F; 1</span><br><span class="line">  let photo &#x3D; DownloadPhoto(url: url!) &#123;</span><br><span class="line">    image, error in</span><br><span class="line">    if let error &#x3D; error &#123;</span><br><span class="line">      XCTFail(&quot;\(urlString) failed. \(error.localizedDescription)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    downloadExpectation.fulfill() &#x2F;&#x2F; 2</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  waitForExpectationsWithTimeout(10) &#123; &#x2F;&#x2F; 3</span><br><span class="line">    error in</span><br><span class="line">    if let error &#x3D; error &#123;</span><br><span class="line">      XCTFail(error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作原理：</p>
<ol>
<li>用<code>expectationWithDescription</code>生成期望。测试会在日志上显示其中的字符串参数，所以请描述你期望发生的事。</li>
<li>在异步执行的闭包中调用<code>fulfill</code>来标记期望已达成。</li>
<li>调用线程用<code>waitForExpectationsWithTimeout</code>等待期望达成。如果等待超时会视为出错。</li>
</ol>
<p>运行测试。结果和使用信号量没什么不同，但使用<code>XCTest</code>框架是更清晰易读的方案。</p>
<h3 id="调度源（Dispatch-Sources）"><a href="#调度源（Dispatch-Sources）" class="headerlink" title="调度源（Dispatch Sources）"></a>调度源（Dispatch Sources）</h3><p>GCD中存在一个特别有趣的特性叫调度源，它是一个包含底层功能的百宝囊，帮助你响应或监控Unix信号，文件描述符（file descriptors），Mach端口，VFS Nodes，以及其他复杂的东西。所有这些都超出了本教程的范围，但是你可以尝试着使用一下调度源对象。</p>
<p>第一次使用调度源的用户可能会迷失其中，所以你首先要理解<code>dispatch_source_create</code>的工作原理。下面是创建它的函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func dispatch_source_create(</span><br><span class="line">  type: dispatch_source_type_t,</span><br><span class="line">  handle: UInt,</span><br><span class="line">  mask: UInt,</span><br><span class="line">  queue: dispatch_queue_t!) -&gt; dispatch_source_t!</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>type: dispatch_source_type_t</code>是最重要的参数，因为它描述了句柄（handle）和掩码（mask）参数。你需要查看<a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/constant_group/Dispatch_Source_Type_Constants" target="_blank" rel="noopener">Xcode文档</a>来弄清楚<code>dispatch_source_type_t</code>的参数有哪些可选项。</p>
<p>这里你会监视<code>DISPATCH_SOURCE_TYPE_SIGNAL</code>。如<a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/c/macro/DISPATCH_SOURCE_TYPE_SIGNAL" target="_blank" rel="noopener">文档</a>所述：</p>
<p>调度源监控当前进程的信号。句柄（handle）是信号数字（int）。掩码（mask）没用到（传0）。</p>
<p>Unix信号列表可以从<a href="http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/signal.h" target="_blank" rel="noopener"><code>signal.h</code></a>找到。在顶部有一串<code>#define</code>。在这些信号列表中，你将要监控<code>SIGSTOP</code>信号。这个信号会在进程接收到不可抗拒的挂起指令时被发送。这个信号与你用LLDB debugger调试程序时发送的信号相同。</p>
<p>进入 <strong>PhotoCollectionViewController.swift</strong> ，在<code>viewDidLoad</code>附近添加下面的代码。你需要为类添加两个私有属性，并在<code>viewDidLoad</code>的开始处添加段代码，在调用superclass和<code>ALAssetLibrary</code>之间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#if DEBUG</span><br><span class="line">private var signalSource: dispatch_source_t!</span><br><span class="line">private var signalOnceToken &#x3D; dispatch_once_t()</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  super.viewDidLoad()</span><br><span class="line"> </span><br><span class="line">  #if DEBUG &#x2F;&#x2F; 1</span><br><span class="line">  dispatch_once(&amp;signalOnceToken) &#123; &#x2F;&#x2F; 2</span><br><span class="line">    let queue &#x3D; dispatch_get_main_queue()</span><br><span class="line">    self.signalSource &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL,</span><br><span class="line">                                               UInt(SIGSTOP), 0, queue) &#x2F;&#x2F; 3</span><br><span class="line">    if let source &#x3D; self.signalSource &#123; &#x2F;&#x2F; 4</span><br><span class="line">      dispatch_source_set_event_handler(source) &#123; &#x2F;&#x2F; 5</span><br><span class="line">        NSLog(&quot;Hi, I am: \(self.description)&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      dispatch_resume(source) &#x2F;&#x2F; 6</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  #endif</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; The other stuff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有点难懂，因此逐个注释来讲解：</p>
<ol>
<li>最好只在DEBUG模式下编译这段代码，因为这可能让不怀好意者洞见很多信息。:] 在 <strong>Project Settings -&gt; Build Settings -&gt; Swift Compiler – Custom Flags -&gt; Other Swift Flags -&gt; Debug</strong> 下添加 <strong>-D DEBUG</strong> 。</li>
<li>用<code>dispatch_once</code>一次性初始化调度源。</li>
<li>初始化<code>signalSource</code>变量。你指明对信号感兴趣并且提供<code>SIGSTOP</code>做第二个参数。除此之外，你用主队列处理接收到的事件——稍后你会发现为什么。</li>
<li>如果参数错误，调度源对象不会被创建。因此，你应该在使用它之前确保调度源是有效的。</li>
<li><code>dispatch_source_set_event_handler</code>注册了一个事件处理闭包，当你接收到监控的信号时会调用这个闭包。</li>
<li>默认情况下，所有调度源在开始都处于挂起状态。当你想监视事件时，必须让源对象继续执行。</li>
</ol>
<p>运行app；暂停调试器然后立即恢复。检查控制台（console），你会看到类似下面的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2014-08-12 12:24:00.514 GooglyPuff[24985:5481978] Hi, I am: &lt;GooglyPuff.PhotoCollectionViewController: 0x7b765ee0&gt;</span><br></pre></td></tr></table></figure>

<p>你的app现在可以感知到调试（debugging-aware）了！这真棒，但在现实中怎样用它呢？</p>
<p>你可以用它调试一个对象并在恢复app时展示数据；你也可以自定义一些安全逻辑来保护app，当恶意攻击者在你的程序上附着调试器的时候。</p>
<p>有趣的想法是把这个方法当做堆栈追踪工具，来找到你想要在调试器中修改的对象。</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/What_Meme.jpg" alt=""></p>
<p>设想一下这样的场景。当你意外地停掉调试器时，你很难处在期望的栈帧上。而现在你可以在任意时刻停止调试器并让代码执行到你期望的位置。这很有用，当你想执行一段从调试器很难达到的代码。试一试！</p>
<p>在<code>viewDidLoad</code>中的<code>NSLog</code>语句处设置断点。暂停调试器，然后再开始；app会命中你刚刚设置的断点。现在你已经深入到<code>PhotoCollectionViewController</code>方法中了。现在你可以随心所欲地使用<code>PhotoCollectionViewController</code>实例了。多么便捷！</p>
<blockquote>
<p><strong>注意</strong>：如果在调试器中你不知道哪个线程是哪个，来看一下。主线程总是第一个，libdispatch，GCD的协调器是第二个。剩下的线程要看硬件当时在做什么样的工作。</p>
</blockquote>
<p>在调试器中，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">po self.navigationItem.prompt &#x3D; &quot;WOOT!&quot;</span><br></pre></td></tr></table></figure>
<p>然后继续执行app。你会看到如下所示：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/08/GooglyPuff_Swift_signal_break.png" alt=""></p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/08/GooglyPuff_Swift_woot-271x500.png" alt=""></p>
<p>通过这个方法，你可以更新UI，探查类的属性，甚至执行方法——无需重启app来进入特定的工作流状态。很巧妙。</p>
<h2 id="下一步？"><a href="#下一步？" class="headerlink" title="下一步？"></a>下一步？</h2><p>下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/01/GooglyPuff_Swift_End_1_Xcode61_final.zip" target="_blank" rel="noopener">最终的工程</a>。</p>
<p>我不想重提，但是你真的应该看一下<a href="http://www.raywenderlich.com/?p=23037" target="_blank" rel="noopener">怎样使用Instruments</a>。如果你想优化app，绝对需要这个。Instruments可以概述程序中哪些代码相对其它代码执行更久。如果你想知道代码实际的执行时间，很可能需要一些自制的解决方案。</p>
<p>同时学习<a href="http://www.raywenderlich.com/?p=76341" target="_blank" rel="noopener">如何在Swift中使用NSOperations和NSOperationQueue</a>，一种基于GCD的并发技术。实际上，这是使用GCD的最佳实践。NSOperations提供更好的控制，处理最多的并发操作，在牺牲一定速度的情况下更加面向对象。</p>
<p>记住，除非你有特别的理由深入底层，你应该始终尝试并坚持使用更高层的API。只在你想学习更多或做一些非常非常“有趣”的事时才进入到Apple的“暗黑艺术”（dark art）中探险。:]</p>
<p>祝你好运，尽情欢乐！</p>
<p>译者：<a href="http://www.loveltyoic.com" target="_blank" rel="noopener">loveltyoic</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2015/01/28/2015-01-28-gcd-1-slash-2/" rel="prev" title="在Swift中应用Grand Central Dispatch(上）">
      <i class="fa fa-chevron-left"></i> 在Swift中应用Grand Central Dispatch(上）
    </a></div>
      <div class="post-nav-item">
    <a href="/2015/02/03/2015-02-03-use-nsoperation-nsoperationqueue-swift/" rel="next" title="在Swift中使用NSOperation 和NSOperationQueue">
      在Swift中使用NSOperation 和NSOperationQueue <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#纠正过早出现的弹窗"><span class="nav-number">1.</span> <span class="nav-text">纠正过早出现的弹窗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调度组（Dispatch-Groups）"><span class="nav-number">1.1.</span> <span class="nav-text">调度组（Dispatch Groups）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度组，再来一次"><span class="nav-number">1.2.</span> <span class="nav-text">调度组，再来一次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发过多带来的危险"><span class="nav-number">2.</span> <span class="nav-text">并发过多带来的危险</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取消调度块"><span class="nav-number">3.</span> <span class="nav-text">取消调度块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五花八门的GCD趣用"><span class="nav-number">4.</span> <span class="nav-text">五花八门的GCD趣用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#测试异步代码"><span class="nav-number">4.1.</span> <span class="nav-text">测试异步代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量"><span class="nav-number">4.2.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#期望（expectations）"><span class="nav-number">4.3.</span> <span class="nav-text">期望（expectations）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度源（Dispatch-Sources）"><span class="nav-number">4.4.</span> <span class="nav-text">调度源（Dispatch Sources）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下一步？"><span class="nav-number">5.</span> <span class="nav-text">下一步？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">李梓赫</p>
  <div class="site-description" itemprop="description">这是一个分享技术与生活感悟的地方</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李梓赫</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
