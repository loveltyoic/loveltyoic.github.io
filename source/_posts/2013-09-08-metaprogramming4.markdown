---
layout: post
title: "Ruby元编程笔记 —— （三） 代码块"
date: 2013-09-08 20:14
comments: true
categories: ruby
---
![](http://farm3.staticflickr.com/2812/9684885545_7ffe7a3990_c.jpg)
* 块是一种控制作用域`scope`的强大手段，作用域指的是哪些代码可以看到哪些变量和方法。
* 调用一个方法时，才可以定义一个块，块会直接传递给这个方法，然后该方法可以用`yield`关键字回调这个块。

<!-- more -->
* `Kernel#block_given?()`询问当前的方法调用是否包含块。
* 局部变量、实例变量、self ...都是绑定在对象上的名字，简称绑定`binding`。块既包含代码，也包含一组绑定。
* 当创建块时会获取到局部绑定，然后把快练同他自己的绑定传递给一个方法。把块称为闭包`closure`。意味着一个块可以获取局部绑定，病一直带着他们。
* 可以在块内部定义额外的绑定，但是这些绑定在块结束时就会消失。
* `Kernel#local_variables()`方法跟踪绑定的名字。
* 只要程序切换了作用域，一些绑定就会被全新的绑定所取代。不过，同一对象的实例变量始终存在于作用域中。
* 作用域门：
  * class 类定义 
  * module 模块定义  
  * def 方法  
  每个关键字充当一个作用域门，关闭前一个作用域，同时打开一个新的作用域。

* 在`main`对象扮演`self`的角色时，可以访问一个顶级实例变量。
* 类和模块中定义的代码会被立即执行，方法中的代码只有被调用时才执行。
* 用`Class.new()`代替`class`

  `Module#define_method()`代替`def`

  可以让一个作用域看到另一个作用域中的变量。如果两个作用域被挤压在一起，他们就可以共享各自的变量，称之为一个扁平作用域`Flat Scope`。
* 假定想在一组方法之间共享一个变量，但是又不希望其他方法访问这个变量，就可以把这些方法定义在那个变量所在的扁平作用域中，称为共享作用域。
* 如果要让绑定穿越作用域门，那么可以用方法调用来代替作用域门：用一个闭包获取当前的绑定，并把这个闭包传递给方法。
* 把传递给`instance_eval()`的块称为一个上下文探针`Context Probe`，它在对象的上下文中执行。
* 创建一个对象，仅仅是为了在其中执行块，这样的对象称为洁净室`Clean Room`
* 一个`Proc`就是一个转换成对象的块，通过把块传给`Proc.new`来创建一个`Proc`，并用`Proc#call()`方法来执行这个由块转换来的对象。这种技术称为延迟执行`Deferred Evaluation`。
* `lambda() 和 proc() 是 Kernel方法`，用于把块转化为`Proc`。
* 块像是方法的额外的匿名参数。在方法中通过`yield`运行一个块，但不能：
  * 把这个块传递给另外一个方法
  * 把这个块转换为一个`Proc`
* 将块附加到一个绑定上，可以给这个方法添加一个特殊的参数，这个参数必须是参数列表中的最后一个，且以`&`符号开头，`&`操作符的真正含义：这是一个`Proc`对象，我想把它当成一个块来使用。使用`&`把`Proc`转换为块。
* 使用`lambda()`创建的`Proc`称为`lambda`
* 在`lambda`中，`return`表示从这个`lambda`中返回；在`proc`中，`return`表示从定义`proc`的作用域中返回。
* 如果调用`lambda`时的参数数量不对，会抛出`ArgumentError`异常。
* 简洁`lambda`
```ruby
  -> (x) { x+1 }
  #等同于
  lambda { |x| x+1 }
```
* 调用`Object#method()`方法可以获得一个用`Method`对象表示的方法，可以用`Method#call`对它进行调用。
* `lambda`在定义它的作用域中执行（他是一个闭包），而`Method`对象会在自身所在对象的作用域中执行。
* `Method#unbind()`把方法和绑定的对象分离，`Method#bind()`可以把这个`UnboundMethod`再次绑定到同属一个类的另一个对象上。
* 可以调用`Method#to_proc()`方法把`Method`对象转换为`Proc`对象，也可以用`define_method()`方法把块转换为`Method`。
* 可调用对象是可以执行的代码片段，他们有自己的作用域，有如下几种形式的可调用对象：
```ruby
  块        -|
  proc       |-->  #定义自身的作用域中执行
  lambda    -| 
  方法              #在所绑定对象的作用域中执行  
```

* DSL(Domain-Specific Language)领域专属语言.
