<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | 大李子的博客]]></title>
  <link href="http://loveltyoic.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://loveltyoic.github.io/"/>
  <updated>2013-11-04T20:28:55+08:00</updated>
  <id>http://loveltyoic.github.io/</id>
  <author>
    <name><![CDATA[李梓赫]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby元编程笔记 —— （四） 类定义]]></title>
    <link href="http://loveltyoic.github.io/blog/2013/09/09/metaprogramming5/"/>
    <updated>2013-09-09T09:14:00+08:00</updated>
    <id>http://loveltyoic.github.io/blog/2013/09/09/metaprogramming5</id>
    <content type="html"><![CDATA[<p><img src="http://farm3.staticflickr.com/2887/9694272518_88a646c15b_o.jpg" alt="" /></p>

<ul>
<li>类只是一个增强的模块。</li>
<li>在类（或模块）定义时，类本身充当了当前对象<code>self</code>的角色。</li>
</ul>


<!-- more -->


<ul>
<li>总是有一个当前类存在，当定义一个方法时，该方法将成为当前类的一个实例方法。</li>
<li>使用<code>class_eval()</code>可以修改当前类。会在一个已存在类的上下文中执行一个块。</li>
<li><code>class</code>关键字会打开一个新的作用域，而<code>class_eval()</code>使用扁平作用域。</li>
<li>如果想打开一个类定义并且用<code>def</code>关键字定义方法，则可以选择<code>class_eval()</code>方法。</li>
<li>在类定义中，当前对象<code>self</code>就是正在定义的类，当前类就是<code>self</code>。如果有一个类的引用，可以用<code>class_eval()</code>或<code>module_eval()</code>打开这个类</li>
<li>所有的实例变量都属于当前对象<code>self</code></li>
<li>在类充当<code>self</code>时定义的变量是类实例变量，仅仅可以被类本身访问，而不能被类的实例或子类所访问。</li>
<li><code>@@</code>开头的是类变量，避免使用。</li>
<li><code>Class#new()</code>方法可以接受一个参数（所建新类的超类）以及一个块，创建一个匿名类。</li>
<li>类名不过是一个常量而已，可以给匿名类赋值，相当于给类命名。</li>
<li>只针对单个对象生效的方法，称为单件方法。</li>
<li>类方法的实质就是：他们是一个类的单件方法。</li>
<li>进入该对象的<code>eigenclass</code>的作用域。
<code>ruby
class &lt;&lt; an_object
</code></li>
<li><code>instance_eval()</code>方法也会修改当前类：它会将当前类修改为接收者的<code>eigenclass</code>，因此可以在其中定义单件方法。</li>
<li><code>instance_eval()</code>方法的标准含义是：我想修改<code>self</code>。</li>
<li>可以在子类中调用父类的类方法。</li>
<li>一个对象的<code>eigenclass</code>的超类是这个对象的类；一个类的<code>eigenclass</code>的超类是这个类的超类的<code>eigenclass</code>。</li>
<li>当类包含模块时，他获得的是该模块的实例方法——而不是类方法。</li>
<li>在类的<code>eigenclass</code>中包含模块，类的<code>eigenclass</code>的实例方法就成了类方法，这种技术称为类扩展<code>Class Extension</code>。更一般的，可以把模块混合到对象的<code>eigenclass</code>，称为对象扩展<code>Object Extension</code>。</li>
<li><code>Object#extend()</code>方法可以简化这种扩展
<code>ruby
obj.extend MyModule #对象扩展
class MyClass   #类扩展
  extend MyModule
end
</code></li>
<li>使用<code>alias</code>关键字，可以给方法取别名。
用法：
<code>ruby
alias :新方法名 :原方法名
alias_method :新方法名, :原方法名  #注意：方法版本，带逗号
</code></li>
<li>重定义一个方法时，并不真正修改这个方法，仍然可以通过别名访问原始的方法。</li>
<li>环绕别名<code>Around Alias</code> 技巧：

<ol>
<li>给方法定义一个别名</li>
<li>重定义这个方法</li>
<li>在重定义方法中调用原始的方法</li>
</ol>
</li>
<li>类宏<code>Class Macro</code>只是普通的类方法，可以用在类定义而已。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby元编程笔记 —— （三） 代码块]]></title>
    <link href="http://loveltyoic.github.io/blog/2013/09/08/metaprogramming4/"/>
    <updated>2013-09-08T20:14:00+08:00</updated>
    <id>http://loveltyoic.github.io/blog/2013/09/08/metaprogramming4</id>
    <content type="html"><![CDATA[<p><img src="http://farm3.staticflickr.com/2812/9684885545_7ffe7a3990_c.jpg" alt="" />
* 块是一种控制作用域<code>scope</code>的强大手段，作用域指的是哪些代码可以看到哪些变量和方法。
* 调用一个方法时，才可以定义一个块，块会直接传递给这个方法，然后该方法可以用<code>yield</code>关键字回调这个块。</p>

<!-- more -->


<ul>
<li><code>Kernel#block_given?()</code>询问当前的方法调用是否包含块。</li>
<li>局部变量、实例变量、self &hellip;都是绑定在对象上的名字，简称绑定<code>binding</code>。块既包含代码，也包含一组绑定。</li>
<li>当创建块时会获取到局部绑定，然后把快练同他自己的绑定传递给一个方法。把块称为闭包<code>closure</code>。意味着一个块可以获取局部绑定，病一直带着他们。</li>
<li>可以在块内部定义额外的绑定，但是这些绑定在块结束时就会消失。</li>
<li><code>Kernel#local_variables()</code>方法跟踪绑定的名字。</li>
<li>只要程序切换了作用域，一些绑定就会被全新的绑定所取代。不过，同一对象的实例变量始终存在于作用域中。</li>
<li><p>作用域门：</p>

<ul>
<li>class 类定义</li>
<li>module 模块定义</li>
<li>def 方法<br/>
每个关键字充当一个作用域门，关闭前一个作用域，同时打开一个新的作用域。</li>
</ul>
</li>
<li><p>在<code>main</code>对象扮演<code>self</code>的角色时，可以访问一个顶级实例变量。</p></li>
<li>类和模块中定义的代码会被立即执行，方法中的代码只有被调用时才执行。</li>
<li><p>用<code>Class.new()</code>代替<code>class</code></p>

<p><code>Module#define_method()</code>代替<code>def</code></p>

<p>可以让一个作用域看到另一个作用域中的变量。如果两个作用域被挤压在一起，他们就可以共享各自的变量，称之为一个扁平作用域<code>Flat Scope</code>。</p></li>
<li>假定想在一组方法之间共享一个变量，但是又不希望其他方法访问这个变量，就可以把这些方法定义在那个变量所在的扁平作用域中，称为共享作用域。</li>
<li>如果要让绑定穿越作用域门，那么可以用方法调用来代替作用域门：用一个闭包获取当前的绑定，并把这个闭包传递给方法。</li>
<li>把传递给<code>instance_eval()</code>的块称为一个上下文探针<code>Context Probe</code>，它在对象的上下文中执行。</li>
<li>创建一个对象，仅仅是为了在其中执行块，这样的对象称为洁净室<code>Clean Room</code></li>
<li>一个<code>Proc</code>就是一个转换成对象的块，通过把块传给<code>Proc.new</code>来创建一个<code>Proc</code>，并用<code>Proc#call()</code>方法来执行这个由块转换来的对象。这种技术称为延迟执行<code>Deferred Evaluation</code>。</li>
<li><code>lambda() 和 proc() 是 Kernel方法</code>，用于把块转化为<code>Proc</code>。</li>
<li>块像是方法的额外的匿名参数。在方法中通过<code>yield</code>运行一个块，但不能：

<ul>
<li>把这个块传递给另外一个方法</li>
<li>把这个块转换为一个<code>Proc</code></li>
</ul>
</li>
<li>将块附加到一个绑定上，可以给这个方法添加一个特殊的参数，这个参数必须是参数列表中的最后一个，且以<code>&amp;</code>符号开头，<code>&amp;</code>操作符的真正含义：这是一个<code>Proc</code>对象，我想把它当成一个块来使用。使用<code>&amp;</code>把<code>Proc</code>转换为块。</li>
<li>使用<code>lambda()</code>创建的<code>Proc</code>称为<code>lambda</code></li>
<li>在<code>lambda</code>中，<code>return</code>表示从这个<code>lambda</code>中返回；在<code>proc</code>中，<code>return</code>表示从定义<code>proc</code>的作用域中返回。</li>
<li>如果调用<code>lambda</code>时的参数数量不对，会抛出<code>ArgumentError</code>异常。</li>
<li>简洁<code>lambda</code>
```ruby
&ndash;> (x) { x+1 }

<h1>等同于</h1>

<p>lambda { |x| x+1 }
```</p></li>
<li>调用<code>Object#method()</code>方法可以获得一个用<code>Method</code>对象表示的方法，可以用<code>Method#call</code>对它进行调用。</li>
<li><code>lambda</code>在定义它的作用域中执行（他是一个闭包），而<code>Method</code>对象会在自身所在对象的作用域中执行。</li>
<li><code>Method#unbind()</code>把方法和绑定的对象分离，<code>Method#bind()</code>可以把这个<code>UnboundMethod</code>再次绑定到同属一个类的另一个对象上。</li>
<li>可以调用<code>Method#to_proc()</code>方法把<code>Method</code>对象转换为<code>Proc</code>对象，也可以用<code>define_method()</code>方法把块转换为<code>Method</code>。</li>
<li><p>可调用对象是可以执行的代码片段，他们有自己的作用域，有如下几种形式的可调用对象：
<code>ruby
块        -|
proc       |--&gt;  #定义自身的作用域中执行
lambda    -|
方法              #在所绑定对象的作用域中执行  
</code></p></li>
<li><p>DSL(Domain-Specific Language)领域专属语言.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby元编程笔记 —— （二） 方法]]></title>
    <link href="http://loveltyoic.github.io/blog/2013/09/03/metaprogramming3/"/>
    <updated>2013-09-03T15:07:00+08:00</updated>
    <id>http://loveltyoic.github.io/blog/2013/09/03/metaprogramming3</id>
    <content type="html"><![CDATA[<p><img src="http://farm3.staticflickr.com/2888/9656919280_8ab725e72a_c.jpg" alt="" /></p>

<ul>
<li>通过<code>Object#send()</code>取代点标记符来调用<code>MyClass#my_method()</code>方法：
<code>ruby
obj = MyClass.new
obj.send(:my_method,arguments)
</code>
通过<code>send()</code>方法，调用的方法名可以是一个参数，这样可以在代码运行期动态决定调用那种方法，这种技术称为动态派发（<code>Dynamic Dispatch</code>）。</li>
</ul>


<!-- more -->


<ul>
<li><p>字符串转符号
<code>String#to_sym()或String#intern()</code></p>

<p>符号转字符串
<code>Symbol#to_s()或Symbol#id2name()</code></p></li>
<li>动态定义方法（<code>Dynamic Method</code>）
在类或模块中，使用<code>define_method()</code>定义一个方法:
<code>ruby
class MyClass
define_method :my_method do |my_arg|
  my_arg * 3
end
end
</code></li>
<li>可以用send()调用任何方法，甚至私有方法。</li>
<li>匹配括号中正则表达式的字符串会存放在$变量中。<code>=~</code>是正则匹配符。</li>
<li><code>method_missing</code>是<code>Kernel</code>的一个实例方法，所有对象均存在。当调用一个不存在的方法时，<code>Kernel#method_missing()</code>方法回抛出一个<code>NoMethodError</code>进行响应。每一个它处理的消息都带着被调用方法的名字，以及所有调用是传递的参数和块。</li>
<li>覆写<code>method_missing</code>方法可以调用接收者实际上不存在的方法，这被称为一个幽灵方法</li>
<li>用<code>super</code>调用被覆写的超类中的同名方法。</li>
<li>一个捕获幽灵方法调用病吧他们转发给另一个对象的对象（有时也会在转发前后包装一些自己的逻辑），称为动态代理。</li>
<li>幽灵方法不是真正的方法，不会出现在<code>Object#methods()</code>获得的方法列表中。</li>
<li>仅在必要时才使用幽灵方法，首先是用一个普通方法来实现功能，当确信代码没有问题时，把这些方法重构到<code>method_missing()</code>中。</li>
<li>当幽灵方法和一个真实方法发生名字冲突时，后者会胜出。</li>
<li>应该在代理类中删除绝大多数继承来的方法，这就是白板（<code>Blank Slate</code>）类。</li>
<li><p>用<code>Module#undef_method()</code>删除所有（包括继承）方法；</p>

<p>用<code>Module#remove_method()</code>删除自身定义的方法。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby元编程笔记 —— （一） 对象模型]]></title>
    <link href="http://loveltyoic.github.io/blog/2013/09/03/metaprogramming2/"/>
    <updated>2013-09-03T10:27:00+08:00</updated>
    <id>http://loveltyoic.github.io/blog/2013/09/03/metaprogramming2</id>
    <content type="html"><![CDATA[<p><img src="http://farm9.staticflickr.com/8465/8079198551_48f29d2544_c.jpg" alt="" /></p>

<ul>
<li>打开类<code>（Open Class）</code></li>
</ul>


<p>  在已有类中动态的添加方法。</p>

<ul>
<li><p>通过<code>Object#methods</code>查看对象的方法，例如数组对象，可以<code>[].methods.grep /正则表达式/</code>查看指定匹配的所有方法名。</p></li>
<li><p>一个对象的实例变量存在于对象本身，而一个对象的方法存在于对象自身的类，称为类的实例方法。</p></li>
</ul>


<!-- more -->


<ul>
<li><p>一个类只不过是一个增强的<code>Module</code>， 增加了三个方法 —— <code>new(),allocate(),superclass()</code>，<code>superclass</code>返回超类。</p></li>
<li><p>类自身也是对象，所有的类最终都继承自<code>Object</code>。</p></li>
<li><p>可以将<code>Module</code>作为命名空间，例如
<code>ruby
Module Book
class Fiction
 ...
</code>
则可以通过<code>Book::Fiction</code>来引用类，有效避免命名冲突。</p></li>
<li><p>接收者<code>(receiver)</code>就是调用方法时所用的对象，祖先链<code>(ancestors)</code>就是从一个类上溯到其顶级超类的整个类路径，可能包括模块。调用<code>ancestors()</code>方法来获得一个类的祖先链：<code>MyClass.ancestors</code></p></li>
<li><p>类中<code>include</code>一个模块时，会将这个模块封装成一个匿名类插入祖先链，在类的正上方，但是通过<code>superclass</code>并不会显示这个匿名类。</p></li>
<li><p>查看类的私有实例方法
<code>ruby
Class.private_instance_methods
</code></p></li>
<li><p><code>self</code>的角色通常是由最后一个接收到方法调用的对象来充当，不过，在类和模块定义中（并且在任何方法定义之外），<code>self</code>的角色由这个类或模块担任：
<code>ruby
class MyClass
self  #=&gt; MyClass
end
</code></p></li>
<li><p>当调用一个方法时，<code>Ruby</code>首先向右一步找到接收者的类，然后一直向上查找祖先链，直到找到该方法，或到达链顶端。</p></li>
<li><p>当一个类中包含多个<code>Module</code>时，最后一个<code>include</code>的<code>Module</code>最接近这个类，其中的方法被最先找到。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby元编程笔记 —— （零） 引言]]></title>
    <link href="http://loveltyoic.github.io/blog/2013/09/03/metaprogramming1/"/>
    <updated>2013-09-03T10:20:00+08:00</updated>
    <id>http://loveltyoic.github.io/blog/2013/09/03/metaprogramming1</id>
    <content type="html"><![CDATA[<p><img src="http://farm9.staticflickr.com/8446/7758810948_ce36812ac9_c.jpg" alt="" /></p>

<ul>
<li>元编程是编写在运行时操纵语言构件的代码。</li>
<li>内省<code>（introspection）</code>
<code>ruby
class Greating
...
end
my_obj = Greeting.new
my_obj.class #=&gt; Greeting 查看对象的类
my_obj.class.instance_methods(false) #=&gt; 查看类的实例方法，false表示只返回自身定义的，不包括继承方法
my_obj.instance_variables #=&gt; 查看对象的实例变量
</code></li>
</ul>

]]></content>
  </entry>
  
</feed>
