<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: UX | Think Different]]></title>
  <link href="http://loveltyoic.github.io/blog/categories/ux/atom.xml" rel="self"/>
  <link href="http://loveltyoic.github.io/"/>
  <updated>2015-06-23T17:00:32+08:00</updated>
  <id>http://loveltyoic.github.io/</id>
  <author>
    <name><![CDATA[李梓赫]]></name>
    <email><![CDATA[loveltyoic@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[D3中的数据绑定--enter()和exit()]]></title>
    <link href="http://loveltyoic.github.io/blog/2014/05/10/d3-data-binding/"/>
    <updated>2014-05-10T20:04:00+08:00</updated>
    <id>http://loveltyoic.github.io/blog/2014/05/10/d3-data-binding</id>
    <content type="html"><![CDATA[<p>最近的几个项目都用到了<a href="http://d3js.org/">D3</a>,各种各样的图也画了一些，算是积攒了一点经验。</p>

<p>在D3的主页上可以看到各种各样的实现例子和源码，基本上常见的图都可以找到，是很好的边做边学的材料。</p>

<p>但是对于初学者来说，比如本人，总会看到一些代码不太能理解，虽然照猫画虎的实现了，但总觉得少了点融会贯通的感觉。
不过随着经验的积累，加上各种大牛的分享，还是摸到了一些门道。</p>

<p>其实D3本质上来说做的就是将数据绑定到元素上去，一切看上去很神奇图型都是建立在这个基础之上的。因此，深入了解D3中的数据绑定是十分必要的。一旦掌握，很容易做到举一反三，即使是一些复杂的图也都不在话下啦。</p>

<!-- more -->


<p>OK，感想到此为止。</p>

<p>Give me example!
<a href="https://gist.github.com/loveltyoic/4d4c8d6fa1c10e46518b">完整代码在这里</a>，可以copy后用chrome等打开，从console中执行其中的三个函数，边看边操作我认为永远是最好的学习方式:)</p>

<p>首先,要讲数据绑定，没数据怎么行</p>

<p>```js
var data_1 = [{x:100,y:100}, {x:200,y:200}, {x:300,y:300}],</p>

<pre><code>data_2 = [{x:50,y:50}, {x:150,y:150}],
data_3 = [{x:400,y:400}, {x:500,y:500}, {x:600,y:600}];
</code></pre>

<p>```</p>

<p>可以看出，这里定义了三组数据，都是数组类型。接下来画一个svg的容器:
<code>js
var svg = d3.select('body').append('svg').attr('width', '800').attr('height', '800');
</code></p>

<p>然后，重点来啦</p>

<p>```js
function draw1(){
  svg.selectAll(&lsquo;circle&rsquo;).data(data_1).enter()</p>

<pre><code>.append('circle')
  .attr('r', '20')
  .attr('cx', function(d){
    return d.x;
  })
  .attr('cy', function(d){
    return d.y;
  });  
</code></pre>

<p>}
```</p>

<p>这是第一个函数，注意里面的<code>data(data_1)</code>，这就是把<code>data_1</code>绑定到所有<code>circle</code>元素上啦。</p>

<p>But wait!根本没有什么<code>circle</code>元素好不好，忽悠谁呢。</p>

<p>的确，这时候还没有<code>circle</code>，但是好戏还在后面呢不是,紧接着不就是<code>enter()</code>了吗。</p>

<p>我在开始的时候，也是完全不懂<code>enter()</code>是神马意思啊，看到例子里面都写，咱也照做呗。但要是一直不去弄懂，那水平也就止于模仿了，何谈超越呢？</p>

<p>这个<code>enter()</code>啊，单独讲还真不好说，这也就是为啥我准备了三个例子，等都看完了，理解的应该就算比较全面了。
就先从这第一讲起吧。</p>

<p>因为没有<code>circle</code>, 此时<code>selectAll('circle')</code>只会返回一个空的数组<code>[]</code>。但神奇的是，这个空的数组上调用<code>enter()</code>后，会生成与这里的<code>data_1</code>等长的一个groups数组，然后将数据一一对应的绑定到groups中的每个元素上去。
具体到这里，因为<code>data_1</code>有三个数据，所以会生成三个元素。</p>

<p>这个占位元素会作为接下来执行操作的容器。比如这里的<code>append('circle')</code>, 就是在元素上画圆点。</p>

<p>最为神奇的是, 因为此时每个元素已经有了自己的数据绑定，我们可以通过<code>function(d){}</code>来获取到绑定的数据。并且还可以用<code>function(d,i){}</code>中的<code>i</code>来获取到数据在数组中的位置。</p>

<p>讲到这里，故事还远远没有结束。</p>

<p>数据往往是变化的，那么图表也应该随之变化才对嘛。</p>

<p>看第二个例子：
```js
function draw2(){
  //part 1
  svg.selectAll(&lsquo;circle&rsquo;).data(data_2).exit().remove();
  //part 2
  svg.selectAll(&lsquo;circle&rsquo;)</p>

<pre><code>  .attr('r', '20')
  .attr('cx', function(d){
    return d.x;
  })
  .attr('cy', function(d){
    return d.y;
  });
</code></pre>

<p>}
```
有enter(),怎么能没有exit()。倒是看看这个exit()有何神通。</p>

<p>看回前面，<code>data_2</code>中只有两个数据，可是在我们运行了draw1()之后，此时就已经有了3个<code>circle</code>元素。可是之后我们却只给它绑定了2个数据，这是二桃杀三士的节奏么？</p>

<p>停止联想，我们还是来看看会发生什么吧。</p>

<p>最后的<code>circle</code>元素因为没有绑定到元素。他的数据会变成null，也就是没有数据。是时候让<code>exit()</code>登场了。</p>

<p>因为这个<code>circle</code>没有数据，他会被exit()捕获，然后就任杀任剐息听尊便啦。一般就是将这个元素从页面上删除，当然还可以用些动画来展现。</p>

<p>不过还有一点必须提到，虽然绑定的数据变化了，但是元素的视图可不会自动的改变。
也就是说，要想更新视图，需要用新数据来更新他们的属性。由part 2实现。</p>

<p>你以为这就结束了吗？还不够！！！</p>

<p>再来看看最后一个例子。
```js
function draw3(){
  //part 1
  svg.selectAll(&lsquo;circle&rsquo;).data(data_3).enter()</p>

<pre><code>.append('circle')
  .attr('r','30');    
</code></pre>

<p>  //part 2  <br/>
  svg.selectAll(&lsquo;circle&rsquo;)</p>

<pre><code>.attr('cx', function(d){
  return d.x;
})
.attr('cy', function(d){
  return d.y;
});
</code></pre>

<p>}
```
数据又更新啦啦啦啦，变成三个点！！！</p>

<p>这个时候<code>enter()</code>会发生什么呢？因为只有2个<code>circle</code>，却绑定了三个数据，自然要生成一个新的元素。</p>

<p>看到没，这里特别将圆点的半径改成30了，当然是有意为之，接着看。</p>

<p>接下来<code>selectAll('circle')</code>，然后重绘他们的坐标位置。</p>

<p>看，新增点的半径是30，但是其他两个点还是20！</p>

<p>这就是玄机啊。当重新绑定数据后再enter(),此时操作的只是groups中新增的那些元素。因为新增了一条数据，会首先生成一个元素容器，然后绑定数据到他身上，再之后的<code>append</code>也只是针对这个新元素，而不会影响已有元素。
对已存在的元素来说，变化的只有绑定的数据。只有再次选择并更新属性，才会变化视图。即part 2的实现。</p>

<p>最后还有一点补充，D3中还有另一个绑定数据的datum()，其实就只是很简单的绑定一条数据到一个元素上。</p>

<p>举个简单例子
```js
var line = d3.svg.line()</p>

<pre><code>         .x(function(d, i) { return i; })
         .y(function(d) { return d; })
</code></pre>

<p>//1           <br/>
svg.append(&lsquo;path&rsquo;)
  .datum([1,2,3])
  .attr(&rsquo;d', line);
//2<br/>
svg.append(&lsquo;path&rsquo;)
  .attr(&rsquo;d', line([1,2,3]));
```           <br/>
看到1和2的区别了么？</p>

<p>1是在画之前用datum绑定数据到path上，虽然数据是个数组，但这与<code>data()</code>的用法相差甚远。</p>

<p>这里的数据同样是数组，却是因为画线需要提供多个点的数据，并且[1,2,3]是只绑定到这个path上的，不会像<code>data()</code>一样有多少数据就生成多少元素。</p>

<p>甚至可以不用<code>datum()</code>，只是在调用<code>line()</code>的时候作为参数给它,像2中的实现方法.</p>

<p>虽然画出来效果是一样的，但区别在于，2的方式没有没有绑定数据到path.</p>

<p>通过<code>selectAll('path').data()</code>一看便知</p>

<p><a href="http://bost.ocks.org/mike/selection/#data">D3作者的文章</a>，甩我这里讲的N条街，真正的深入理解，感谢作者！</p>

<p>乎，好久没更新文章了，写blog其实真的蛮有快感呐。即使文笔再烂，即使水平有限，但分享永远是快乐的！</p>
]]></content>
  </entry>
  
</feed>
